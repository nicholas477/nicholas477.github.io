<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Multipass Post Processing Effects Using Scene View Extensions | </title> <meta name="author" content="Nicholas Chalkley"> <meta name="description" content="Unreal engine rantings and ravings "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website, unreal-engine"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://nicholas477.github.io//blog/2023/multipass_pp/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"></a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item"> <a class="nav-link" href="https://epicgameguy.itch.io" rel="external nofollow noopener" target="_blank">games </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item"> <a class="nav-link" href="https://www.unrealengine.com/marketplace/en-US/profile/Big+Cat+Energising" rel="external nofollow noopener" target="_blank">marketplace </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Multipass Post Processing Effects Using Scene View Extensions</h1> <p class="post-meta">October 21, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p> </header> <article class="post-content"> <h1 id="overview">Overview</h1> <p>I wanted to make the security cameras in my game to look like old CCD cameras. In particular, I wanted the cameras to look deinterlaced, low res, and I wanted them to have a light streaking effect. You can see what i’m talking about in the video below.</p> <iframe width="100%" height="480" src="https://www.youtube.com/embed/pAb1qpXoXck" title="Newvicon tube video camera light streaking effect" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <p>The low res effect is super easy, I just got that done using Unreal’s built in post processing materials. For the deinterlacing effect, I decided that I would do it by just writing half the horizontal lines each frame. And I decided I would do the light streaking by combining accumulation motion blur with a brightness mask.</p> <p>Once I decided how I was going to do the deinterlacing and streaking effects, I tried using <a href="https://docs.unrealengine.com/5.3/en-US/post-process-materials-in-unreal-engine/" rel="external nofollow noopener" target="_blank">Unreal’s post processing materials</a> to implement them, but they are pretty limited. You can’t read the last frame or write to arbitrary render targets with the effects, so doing any sort of accumulative effects (like motion blur) are impossible. The rendering side of Unreal is generally pretty locked down and normally something like this wouldn’t be possible without modifying the engine, but fortunately Unreal has a way to extend the renderer without modifying the engine. These extensions are called <a href="https://github.com/EpicGames/UnrealEngine/blob/5ccd1d8b91c944d275d04395a037636837de2c56/Engine/Source/Runtime/Engine/Public/SceneViewExtension.h#L99C9-L99C9" rel="external nofollow noopener" target="_blank">Scene View Extensions</a>.</p> <h2 id="scene-view-extensions">Scene View Extensions</h2> <p>Scene view extensions are programmable rendering extensions that let you run rendering code at different parts of the rendering pipeline. They also let you add in a pass to the post processing stack at different parts of the post processing pipeline. I’ve actually used them before to implement a <a href="https://youtu.be/gCus1za5iho" rel="external nofollow noopener" target="_blank">volumetric fog effect</a> and a custom mesh render pass.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/multipass-pp/custom_render_pass-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/multipass-pp/custom_render_pass-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/multipass-pp/custom_render_pass-1400.webp"></source> <img src="/assets/img/multipass-pp/custom_render_pass.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Custom Render Pass using Scene View Extension" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Using a scene view extension, I was able to add a mesh render pass that would draw after SSR and motion blur, but before bloom. </div> <p>So using extensions, you can add in a post processing pass with much more control than the material post processing passes built into the engine. You have full control over creating render targets, what shaders are ran, what parameters are passed to the shaders, what passes are ran, etc. You can basically do anything.</p> <p>But the drawback is that it isn’t as simple as the material post processing passes. You have to write rendering code and interface it with game code, which can be a bit daunting if you’re unfamiliar with writing multithreaded code in Unreal. Also since the view extensions are very general purpose, they require a lot of boilerplate code to set up the render targets and insert a post processing pass. Lastly, there’s some oddities with the renderer that you have to work around, such as in-editor regional rendering and an issue with how render targets are presented. I don’t think these issues are too interesting, so I went over them in the <code class="language-plaintext highlighter-rouge">Issues</code> section at the bottom of the article. Instead I will go over how I implemented the post process passes.</p> <h2 id="implementing-post-processing-passes">Implementing post processing passes</h2> <p>I wrote a <a href="https://github.com/nicholas477/MultipassPP" rel="external nofollow noopener" target="_blank">plugin that helps you implement your own post processing passes with scene view extensions</a>, so the rest of this section will just be a high level overview of how to implement your own scene view extension from scratch. If you want to see working examples then peruse the plugin.</p> <p>If you want to write your own post processing pass then I recommend just using the plugin instead of writing the extension entirely from scratch. The interlacing effect and motion blur effect are included in the plugin for you to edit however you like.</p> <h4 id="creating-the-scene-view-extension">Creating the scene view extension</h4> <p>Creating a scene view extension and getting the engine to run it is pretty straightforward. You subclass <code class="language-plaintext highlighter-rouge">FSceneViewExtensionBase</code> or <code class="language-plaintext highlighter-rouge">FWorldSceneViewExtension</code>, implement the pure virtual methods, and call <code class="language-plaintext highlighter-rouge">FSceneViewExtensions::NewExtension()</code> with your extension.</p> <p>A good example of how to do this is <a href="https://github.com/EpicGames/UnrealEngine/blob/5ccd1d8b91c944d275d04395a037636837de2c56/Engine/Plugins/Media/MediaIOFramework/Source/MediaIOCore/Private/MediaCaptureSceneViewExtension.h#L23" rel="external nofollow noopener" target="_blank">FMediaCaptureSceneViewExtension</a>. You will want to focus on <code class="language-plaintext highlighter-rouge">SubscribeToPostProcessingPass</code> and <code class="language-plaintext highlighter-rouge">PostProcessCallback_RenderThread</code>. In your scene view extension, you override <code class="language-plaintext highlighter-rouge">SubscribeToPostProcessingPass</code> and pass a delegate to the <code class="language-plaintext highlighter-rouge">FAfterPassCallbackDelegateArray&amp; InOutPassCallbacks</code> to add in your post process pass. That’s basically all you have to do in your extension. Then in the function delegate you passed, you just do your rendering pass code there and use the <code class="language-plaintext highlighter-rouge">FPostProcessMaterialInputs</code> for the RT inputs/output. You can get the scene color from the <code class="language-plaintext highlighter-rouge">FPostProcessMaterialInputs</code> and you either use the <code class="language-plaintext highlighter-rouge">OverrideOutput</code> RT or your own RT for the output, and you return the outputted RT in your function. You can see this being done in the <a href="https://github.com/EpicGames/UnrealEngine/blob/5ccd1d8b91c944d275d04395a037636837de2c56/Engine/Plugins/Compositing/OpenColorIO/Source/OpenColorIO/Private/OpenColorIODisplayExtension.cpp#L73C12-L73C12" rel="external nofollow noopener" target="_blank">OpenColorIODisplayExtension</a> code here. If you want to use a custom shader for the extension, you can see how to do that <a href="https://github.com/EpicGames/UnrealEngine/blob/5ccd1d8b91c944d275d04395a037636837de2c56/Engine/Plugins/Compositing/OpenColorIO/Source/OpenColorIO/Private/OpenColorIORendering.cpp#L92C3-L92C20" rel="external nofollow noopener" target="_blank">here</a>, in the OpenColorIO code.</p> <p>Now to actually get your extension to run, you will have to create it. In your module startup code (or wherever you want to add the extension) call <code class="language-plaintext highlighter-rouge">FSceneViewExtensions::NewExtension&lt;FYourExtensionType&gt;()</code> and hold a reference to your new view extension. My code for creating the new extension in my module looks like this:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td> <td class="code"><pre><span class="kt">void</span> <span class="n">FMultipassPPModule</span><span class="o">::</span><span class="n">StartupModule</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">FString</span> <span class="n">PluginShaderDir</span> <span class="o">=</span> <span class="n">FPaths</span><span class="o">::</span><span class="n">Combine</span><span class="p">(</span><span class="n">IPluginManager</span><span class="o">::</span><span class="n">Get</span><span class="p">().</span><span class="n">FindPlugin</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"MultipassPP"</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">GetBaseDir</span><span class="p">(),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Shaders"</span><span class="p">));</span>
	<span class="n">AddShaderSourceDirectoryMapping</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"/MultipassPP"</span><span class="p">),</span> <span class="n">PluginShaderDir</span><span class="p">);</span>

	<span class="c1">// Wait for engine init, and create the new extension</span>
	<span class="n">FCoreDelegates</span><span class="o">::</span><span class="n">OnPostEngineInit</span><span class="p">.</span><span class="n">AddLambda</span><span class="p">([</span><span class="k">this</span><span class="p">]()</span>
	<span class="p">{</span>	
		<span class="n">InterlaceSceneExtension</span> <span class="o">=</span> <span class="n">FSceneViewExtensions</span><span class="o">::</span><span class="n">NewExtension</span><span class="o">&lt;</span><span class="n">FInterlacePPSceneExtension</span><span class="o">&gt;</span><span class="p">();</span>
		<span class="n">MotionBlurSceneExtension</span> <span class="o">=</span> <span class="n">FSceneViewExtensions</span><span class="o">::</span><span class="n">NewExtension</span><span class="o">&lt;</span><span class="n">FAccumulationMotionBlurSceneExtension</span><span class="o">&gt;</span><span class="p">();</span>
	<span class="p">});</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>Note: One thing you will want to make sure you do is call <code class="language-plaintext highlighter-rouge">FSceneViewExtensions::NewExtension</code> only after the engine is initialized. This is generally not an issue since most code modules are loaded after the engine by default, but I had to load my module before the engine to be able to add the shader source mapping. Because my module is loaded before the engine I just bound a lambda to engine init and created my extension there.</p> <p>And you’re done! The view extension should now be ran by the renderer after it is created. If you didn’t want to do temporal effects with your scene view extension, you can stop here. Otherwise, continue on to the <code class="language-plaintext highlighter-rouge">Managing a render target for temporal effects</code> section.</p> <h4 id="managing-a-render-target-for-temporal-effects">Managing a render target for temporal effects</h4> <p>If you want to do a persistent post processing effect with your scene view extension, your extension will require a bit of extra work. You will have to store an extra render target in your scene view extension to handle the persistent effects. Trying to figure out how to properly do this proved to be a big issue. At first, I tried using a single render target for the temporal effects, but I ran into issues with multiple editor views clobbering each other’s render targets. And I also ran into issues when the camera would switch from one view to another. It would not clear the last frame’s render target so the blur was accumulated between cameras when it shouldn’t have. To fix these issues, I looked through the engine code and tried to find any scene view extensions that had render targets or handled multiple views, but I couldn’t find any.</p> <p>So after some experimentation with associating RTs with scene view families and cameras, I found that associating RTs with scene view indices was the best way to fix my issues. In my scene view extension, I set up a map of view indices to view data:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> <td class="code"><pre><span class="k">struct</span> <span class="nc">MULTIPASSPP_API</span> <span class="n">FMultipassPPViewData</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IMultipassPPViewData</span>
<span class="p">{</span>
	<span class="k">virtual</span> <span class="n">TRefCountPtr</span><span class="o">&lt;</span><span class="n">IPooledRenderTarget</span><span class="o">&gt;</span> <span class="n">GetRT</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">RT</span><span class="p">;</span> <span class="p">};</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">SetupRT</span><span class="p">(</span><span class="k">const</span> <span class="n">FIntPoint</span><span class="o">&amp;</span> <span class="n">Resolution</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>

	<span class="n">TRefCountPtr</span><span class="o">&lt;</span><span class="n">IPooledRenderTarget</span><span class="o">&gt;</span> <span class="n">RT</span><span class="p">;</span>
	<span class="n">FString</span> <span class="n">RTDebugName</span> <span class="o">=</span> <span class="s">"Multipass PP View Data RT"</span><span class="p">;</span>
	<span class="n">EPixelFormat</span> <span class="n">RTPixelFormat</span> <span class="o">=</span> <span class="n">EPixelFormat</span><span class="o">::</span><span class="n">PF_B8G8R8A8</span><span class="p">;</span> <span class="c1">// Equivalent to ETextureRenderTargetFormat::RTF_RGBA8_SRGB</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MULTIPASSPP_API</span> <span class="n">FMultipassPPSceneExtension</span> <span class="o">:</span> <span class="k">public</span> <span class="n">FSceneViewExtensionBase</span>
<span class="p">{</span>
	<span class="c1">// Map of ViewState index to ViewData</span>
	<span class="c1">// Each view should have a ViewData associated to it</span>
	<span class="n">TMap</span><span class="o">&lt;</span><span class="n">uint32</span><span class="p">,</span> <span class="n">TSharedPtr</span><span class="o">&lt;</span><span class="n">IMultipassPPViewData</span><span class="o">&gt;&gt;</span> <span class="n">ViewDataMap</span><span class="p">;</span>
<span class="p">};</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>I constructed the view data in the <a href="https://github.com/nicholas477/MultipassPP/blob/e6ebac603f3c4ca5f41a3bf3e5a6b480263b2fcd/Source/MultipassPP/Private/MultipassPPSceneExtension.cpp#L21C17-L21C17" rel="external nofollow noopener" target="_blank">SetupView</a> function in my scene extension, and during my post processing pass I <a href="https://github.com/nicholas477/MultipassPP/blob/e6ebac603f3c4ca5f41a3bf3e5a6b480263b2fcd/Source/MultipassPP/Private/MultipassPPSceneExtension.cpp#L44C46-L44C57" rel="external nofollow noopener" target="_blank">looked up the view data from the scene view</a> and used that.</p> <h4 id="bringing-it-all-together">Bringing it all together</h4> <p>There’s a few more issues I had with creating my scene view extension that I talk about in the bottom of this article, but other than that the post processing pass is basically done. The next steps are to just write the shaders, bind their resources, and run them in the post processing pass. You can see the code for that <a href="https://github.com/nicholas477/MultipassPP/blob/e6ebac603f3c4ca5f41a3bf3e5a6b480263b2fcd/Source/MultipassPP/Public/MultipassPPSceneExtension.h#L107C28-L107C28" rel="external nofollow noopener" target="_blank">here</a>.</p> <p>You can see the finished effects in this video:</p> <iframe width="100%" height="480" src="https://www.youtube.com/embed/rTjeTTfy6VI" title="Security camera post processing" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe> <p>The streaking still needs some tweaking and maybe some subsampling, but I’m pretty happy with how it turned out. I included the two post processing effects in my plugin, and you can download it from the downloads section.</p> <h2 id="issues">Issues</h2> <h4 id="regional-rendering">Regional Rendering</h4> <p>When you make the editor viewport bigger, the render targets used for rendering are all resized to a bigger size, but the same is not true when you make the viewport smaller. The editor doesn’t resize the render targets smaller, but instead just renders to a smaller region of the render targets.</p> <p>Generally this is something that you never have to deal with if you don’t write rendering code since the engine handles it transparently, but I did have to deal with it in my motion blur extension. It doesn’t seem like you can get the size of the entire render target used in editor in Unreal when you are setting up the render targets in <code class="language-plaintext highlighter-rouge">ISceneViewExtension::SetupView</code>, so the render target mismatch caused my UVs to be messed up. I ended up rescaling the UVs for the RT in my pixel shader.</p> <figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td> <td class="code"><pre><span class="n">float2</span> <span class="n">UV</span> <span class="o">=</span> <span class="n">UVAndScreenPos</span><span class="p">.</span><span class="n">xy</span><span class="p">;</span>
	
<span class="c1">// The UVs are scaled to the size of the UV rect of the viewport, so we need to unscale</span>
<span class="c1">// the UVs for reading from the output texture</span>
<span class="n">float2</span> <span class="n">OutputUVs</span> <span class="o">=</span> <span class="p">(</span><span class="n">float2</span><span class="p">(</span><span class="n">InputTextureSize</span><span class="p">)</span> <span class="o">/</span> <span class="n">float2</span><span class="p">(</span><span class="n">OutputTextureSize</span><span class="p">))</span> <span class="o">*</span> <span class="n">UV</span><span class="p">;</span>
	
<span class="k">const</span> <span class="kt">float</span> <span class="n">FrameRate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span> <span class="o">/</span> <span class="n">DeltaTime</span><span class="p">;</span>

<span class="kt">float</span> <span class="n">Weight</span> <span class="o">=</span> <span class="n">exp</span><span class="p">(</span><span class="n">log</span><span class="p">(</span><span class="n">FadeWeight</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">FrameRate</span> <span class="o">*</span> <span class="n">FadeTime</span><span class="p">));</span>
<span class="n">Weight</span> <span class="o">=</span> <span class="n">saturate</span><span class="p">(</span><span class="n">Weight</span><span class="p">);</span>
	
<span class="k">if</span> <span class="p">(</span><span class="n">LastFrameNumber</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span><span class="p">).</span><span class="n">rgb</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
	
<span class="n">float3</span> <span class="n">PrevFrame</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">MotionBlurTexture</span><span class="p">,</span> <span class="n">MotionBlurSampler</span><span class="p">,</span> <span class="n">OutputUVs</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
<span class="n">float3</span> <span class="n">CurFrame</span> <span class="o">=</span> <span class="n">Texture2DSample</span><span class="p">(</span><span class="n">InputTexture</span><span class="p">,</span> <span class="n">InputSampler</span><span class="p">,</span> <span class="n">UV</span><span class="p">).</span><span class="n">rgb</span><span class="p">;</span>
	
<span class="n">float3</span> <span class="n">Output</span> <span class="o">=</span> <span class="n">lerp</span><span class="p">(</span><span class="n">CurFrame</span><span class="p">,</span> <span class="n">PrevFrame</span><span class="p">,</span> <span class="n">Weight</span><span class="p">);</span>
</pre></td> </tr></tbody></table></code></pre></figure> <h4 id="presenting-rts">Presenting RTs</h4> <p>Depending on the post processing settings, I would have to enable my post processing pass but never actually run the post processing shader. When this happened, the screen would be frozen and I had no idea why. I was using a post processing bypass function used by scene view extensions in the engine called <code class="language-plaintext highlighter-rouge">ReturnUntouchedSceneColorForPostProcessing</code>, and it seems like it should have worked.</p> <p>The issue I had with how the output render target is actually presented is that sometimes the engine gives you a render target to write to, and sometimes it doesn’t. The bypass code I found in the engine’s scene view extensions don’t take this into account, and I was scratching my head for a while trying to figure out why it doesn’t work.</p> <p>The engine’s bypass code looks like this:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td> <td class="code"><pre><span class="cm">/** 
* A helper function that extracts the right scene color texture, untouched, to be used further in post processing. 
*/</span>
<span class="n">FScreenPassTexture</span> <span class="nf">ReturnUntouchedSceneColorForPostProcessing</span><span class="p">(</span><span class="k">const</span> <span class="n">FPostProcessMaterialInputs</span><span class="o">&amp;</span> <span class="n">InOutInputs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">InOutInputs</span><span class="p">.</span><span class="n">OverrideOutput</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">InOutInputs</span><span class="p">.</span><span class="n">OverrideOutput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/** We don't want to modify scene texture in any way. We just want it to be passed back onto the next stage. */</span>
		<span class="n">FScreenPassTexture</span> <span class="n">SceneTexture</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">FScreenPassTexture</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">InOutInputs</span><span class="p">.</span><span class="n">Textures</span><span class="p">[(</span><span class="n">uint32</span><span class="p">)</span><span class="n">EPostProcessMaterialInput</span><span class="o">::</span><span class="n">SceneColor</span><span class="p">]);</span>
		<span class="k">return</span> <span class="n">SceneTexture</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>You can see it just returns either the output override RT or the inputted scene texture if the override output doesn’t exist. The issue with this is that the override output RT doesn’t actually have anything written to it if it does exist, so if you present it then it just looks like the scene rendering froze. Once I figured out that that was the issue, I added a pass that copies the scene color RT to the output override and fixed the issue. You can see this implemented in the code below:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre></td> <td class="code"><pre><span class="n">FScreenPassTexture</span> <span class="nf">ReturnUntouchedSceneColorForPostProcessing</span><span class="p">(</span><span class="n">FRDGBuilder</span><span class="o">&amp;</span> <span class="n">GraphBuilder</span><span class="p">,</span> <span class="k">const</span> <span class="n">FSceneView</span><span class="o">&amp;</span> <span class="n">View</span><span class="p">,</span> <span class="k">const</span> <span class="n">FViewInfo</span><span class="o">&amp;</span> <span class="n">ViewInfo</span><span class="p">,</span> <span class="k">const</span> <span class="n">FPostProcessMaterialInputs</span><span class="o">&amp;</span> <span class="n">InOutInputs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// If OverrideOutput is valid, we need to write to it, even if we're bypassing pp rendering</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">InOutInputs</span><span class="p">.</span><span class="n">OverrideOutput</span><span class="p">.</span><span class="n">IsValid</span><span class="p">())</span>
	<span class="p">{</span>
		<span class="n">FCopyRectPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">*</span> <span class="n">Parameters</span> <span class="o">=</span> <span class="n">GraphBuilder</span><span class="p">.</span><span class="n">AllocParameters</span><span class="o">&lt;</span><span class="n">FCopyRectPS</span><span class="o">::</span><span class="n">FParameters</span><span class="o">&gt;</span><span class="p">();</span>
		<span class="n">Parameters</span><span class="o">-&gt;</span><span class="n">InputTexture</span> <span class="o">=</span> <span class="n">InOutInputs</span><span class="p">.</span><span class="n">GetInput</span><span class="p">(</span><span class="n">EPostProcessMaterialInput</span><span class="o">::</span><span class="n">SceneColor</span><span class="p">).</span><span class="n">Texture</span><span class="p">;</span>
		<span class="n">Parameters</span><span class="o">-&gt;</span><span class="n">InputSampler</span> <span class="o">=</span> <span class="n">TStaticSamplerState</span><span class="o">&lt;&gt;::</span><span class="n">GetRHI</span><span class="p">();</span>
		<span class="n">Parameters</span><span class="o">-&gt;</span><span class="n">RenderTargets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">InOutInputs</span><span class="p">.</span><span class="n">OverrideOutput</span><span class="p">.</span><span class="n">GetRenderTargetBinding</span><span class="p">();</span>

		<span class="k">const</span> <span class="n">FGlobalShaderMap</span><span class="o">*</span> <span class="n">GlobalShaderMap</span> <span class="o">=</span> <span class="n">GetGlobalShaderMap</span><span class="p">(</span><span class="n">View</span><span class="p">.</span><span class="n">FeatureLevel</span><span class="p">);</span>

		<span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FCopyRectPS</span><span class="o">&gt;</span> <span class="n">CopyPixelShader</span><span class="p">(</span><span class="n">GlobalShaderMap</span><span class="p">);</span>
		<span class="n">TShaderMapRef</span><span class="o">&lt;</span><span class="n">FScreenPassVS</span><span class="o">&gt;</span> <span class="n">ScreenPassVS</span><span class="p">(</span><span class="n">GlobalShaderMap</span><span class="p">);</span>

		<span class="k">const</span> <span class="n">FScreenPassTextureViewport</span> <span class="n">InputViewport</span><span class="p">(</span><span class="n">InOutInputs</span><span class="p">.</span><span class="n">GetInput</span><span class="p">(</span><span class="n">EPostProcessMaterialInput</span><span class="o">::</span><span class="n">SceneColor</span><span class="p">));</span>
		<span class="k">const</span> <span class="n">FScreenPassTextureViewport</span> <span class="n">OutputViewport</span><span class="p">(</span><span class="n">InOutInputs</span><span class="p">.</span><span class="n">OverrideOutput</span><span class="p">);</span>

		<span class="n">FRHIBlendState</span><span class="o">*</span> <span class="n">CopyBlendState</span> <span class="o">=</span> <span class="n">FScreenPassPipelineState</span><span class="o">::</span><span class="n">FDefaultBlendState</span><span class="o">::</span><span class="n">GetRHI</span><span class="p">();</span>
		<span class="n">FRHIDepthStencilState</span><span class="o">*</span> <span class="n">DepthStencilState</span> <span class="o">=</span> <span class="n">FScreenPassPipelineState</span><span class="o">::</span><span class="n">FDefaultDepthStencilState</span><span class="o">::</span><span class="n">GetRHI</span><span class="p">();</span>
		<span class="n">AddDrawScreenPass</span><span class="p">(</span><span class="n">GraphBuilder</span><span class="p">,</span> <span class="n">FRDGEventName</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"ReturnUntouchedSceneColorForPostProcessing"</span><span class="p">)),</span> <span class="n">ViewInfo</span><span class="p">,</span> <span class="n">OutputViewport</span><span class="p">,</span> <span class="n">InputViewport</span><span class="p">,</span> <span class="n">ScreenPassVS</span><span class="p">,</span> <span class="n">CopyPixelShader</span><span class="p">,</span> <span class="n">CopyBlendState</span><span class="p">,</span> <span class="n">DepthStencilState</span><span class="p">,</span> <span class="n">Parameters</span><span class="p">,</span> <span class="n">EScreenPassDrawFlags</span><span class="o">::</span><span class="n">None</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">InOutInputs</span><span class="p">.</span><span class="n">OverrideOutput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="cm">/** We don't want to modify scene texture in any way. We just want it to be passed back onto the next stage. */</span>
		<span class="n">FScreenPassTexture</span> <span class="n">SceneTexture</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="n">FScreenPassTexture</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">InOutInputs</span><span class="p">.</span><span class="n">Textures</span><span class="p">[(</span><span class="n">uint32</span><span class="p">)</span><span class="n">EPostProcessMaterialInput</span><span class="o">::</span><span class="n">SceneColor</span><span class="p">]);</span>
		<span class="k">return</span> <span class="n">SceneTexture</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <h1 id="download-links">Download Links</h1> <ul> <li><a href="https://github.com/nicholas477/MultipassPP" rel="external nofollow noopener" target="_blank">Plugin Link</a></li> </ul> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Nicholas Chalkley. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: June 30, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script type="text/javascript">$(function(){$('[data-toggle="tooltip"]').tooltip()});</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-8SQ3HQJMBJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-8SQ3HQJMBJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>