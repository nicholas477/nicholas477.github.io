<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Asynchronously Reading Render Targets Using Fences | </title> <meta name="author" content="Nicholas Chalkley"> <meta name="description" content="Unreal engine rantings and ravings "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website, unreal-engine"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css"> <link rel="canonical" href="https://nicholas477.github.io//blog/2023/reading-rt/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js"></script> <script src="/assets/js/dark_mode.js"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"></a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item"> <a class="nav-link" href="https://epicgameguy.itch.io" rel="external nofollow noopener" target="_blank">games </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories</a> </li> <li class="nav-item"> <a class="nav-link" href="https://www.unrealengine.com/marketplace/en-US/profile/Big+Cat+Energising" rel="external nofollow noopener" target="_blank">marketplace </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Asynchronously Reading Render Targets Using Fences</h1> <p class="post-meta">September 15, 2023</p> <p class="post-tags"> <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a> </p> </header> <article class="post-content"> <p><a href="https://github.com/EpicGames/UnrealEngine/blob/5ccd1d8b91c944d275d04395a037636837de2c56/Engine/Source/Runtime/Engine/Private/UnrealClient.cpp#L61" rel="external nofollow noopener" target="_blank">Unreal has a built-in function for reading pixels from a render target</a> but its awful. This single call blocks the game thread and can take milliseconds to complete since it flushes the RHI command queue.</p> <div class="row justify-content-sm-center"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/read-pixels-sycnhronous-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/read-pixels-sycnhronous-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/read-pixels-sycnhronous-1400.webp"></source> <img src="/assets/img/read-pixels-sycnhronous.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Synchronous Pixel Reading" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> Calling this function a single time took the blueprint CPU time for this example scene from a few microseconds to 4 milliseconds(!!!) </div> <p>I found other people complaining on the forums about this, but I couldn’t find any workarounds online. So I ended up digging into the engine and found some places where Unreal reads back a RT to the CPU <a href="https://github.com/EpicGames/UnrealEngine/blob/5ccd1d8b91c944d275d04395a037636837de2c56/Engine/Plugins/Experimental/GPULightmass/Source/GPULightmass/Private/Scene/Scene.cpp#L1733" rel="external nofollow noopener" target="_blank">using a different method</a>. The method they use involves creating a temporary texture with the <code class="language-plaintext highlighter-rouge">CPUReadback</code> flag, copying the RT to that texture, and then mapping and reading the temp texture. On first glance, it seems like it avoids the synchronization issues that <code class="language-plaintext highlighter-rouge">FRenderTarget::ReadPixels</code> has.</p> <p>Unfortunately, the mapping function this method uses, <code class="language-plaintext highlighter-rouge">FRHICommandListImmediate::MapStagingSurface</code>, still flushes the command list. But I dug into the engine code a bit more and found out that the function actually calls <code class="language-plaintext highlighter-rouge">FDynamicRHI::RHIMapStagingSurface</code> after flushing. Therefore you can get around flushing by just using <code class="language-plaintext highlighter-rouge">FDynamicRHI::RHIMapStagingSurface</code> instead.</p> <p>But using this function presents yet another problem. Since this function doesn’t flush the command queue you can run into GPU/CPU synchronization issues. If you call <code class="language-plaintext highlighter-rouge">MapStagingSurface</code> right after the texture copy, then you’ll end up reading garbage or old data. This is where <a href="https://learn.microsoft.com/en-us/windows/win32/api/d3d12/nn-d3d12-id3d12fence" rel="external nofollow noopener" target="_blank">render fences</a> come in. If you’re unfamiliar with what a render fence is, it’s an object you can push onto the command queue that signals when the commands preceding it are completed by the GPU. On the CPU side, you can poll the fence to check if its done or wait for it to be done. Using this, you can avoid flushing the GPU and instead just periodically check if the commands are done.</p> <p>So to avoid the aforementioned flush, I set up my texture creation and copy to use a render fence:</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td> <td class="code"><pre><span class="n">FRHIResourceCreateInfo</span> <span class="nf">CreateInfo</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"AsyncRTReadback"</span><span class="p">));</span>
<span class="n">FTexture2DRHIRef</span> <span class="n">AsyncReadTexture</span> <span class="o">=</span> <span class="n">RHICreateTexture2D</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TextureRHI</span><span class="o">-&gt;</span><span class="n">GetFormat</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">TexCreate_CPUReadback</span><span class="p">,</span> <span class="n">ERHIAccess</span><span class="o">::</span><span class="n">CopyDest</span><span class="p">,</span> <span class="n">CreateInfo</span><span class="p">);</span>

<span class="n">FRHICopyTextureInfo</span> <span class="n">CopyTextureInfo</span><span class="p">;</span>
<span class="n">CopyTextureInfo</span><span class="p">.</span><span class="n">Size</span> <span class="o">=</span> <span class="n">FIntVector</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">CopyTextureInfo</span><span class="p">.</span><span class="n">SourceMipIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">CopyTextureInfo</span><span class="p">.</span><span class="n">DestMipIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">CopyTextureInfo</span><span class="p">.</span><span class="n">SourcePosition</span> <span class="o">=</span> <span class="n">FIntVector</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">CopyTextureInfo</span><span class="p">.</span><span class="n">DestPosition</span> <span class="o">=</span> <span class="n">FIntVector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="n">RHICmdList</span><span class="p">.</span><span class="n">Transition</span><span class="p">(</span><span class="n">FRHITransitionInfo</span><span class="p">(</span><span class="n">TextureRHI</span><span class="p">,</span> <span class="n">ERHIAccess</span><span class="o">::</span><span class="n">Unknown</span><span class="p">,</span> <span class="n">ERHIAccess</span><span class="o">::</span><span class="n">CopySrc</span><span class="p">));</span>
<span class="n">RHICmdList</span><span class="p">.</span><span class="n">CopyTexture</span><span class="p">(</span><span class="n">TextureRHI</span><span class="p">,</span> <span class="n">AsyncReadTexture</span><span class="p">,</span> <span class="n">CopyTextureInfo</span><span class="p">);</span>

<span class="n">RHICmdList</span><span class="p">.</span><span class="n">Transition</span><span class="p">(</span><span class="n">FRHITransitionInfo</span><span class="p">(</span><span class="n">AsyncReadTexture</span><span class="p">,</span> <span class="n">ERHIAccess</span><span class="o">::</span><span class="n">CopyDest</span><span class="p">,</span> <span class="n">ERHIAccess</span><span class="o">::</span><span class="n">CopySrc</span><span class="p">));</span>

<span class="n">FGPUFenceRHIRef</span> <span class="n">Fence</span> <span class="o">=</span> <span class="n">RHICreateGPUFence</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"AsyncRTReadback"</span><span class="p">));</span>
<span class="n">RHICmdList</span><span class="p">.</span><span class="n">WriteGPUFence</span><span class="p">(</span><span class="n">Fence</span><span class="p">);</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>And to make sure the map runs after the texture is copied I just held a reference to the temporary texture and the render fence, polled the fence on game tick, and <em>then</em> mapped the texture read.</p> <figure class="highlight"><pre><code class="language-c--" data-lang="c++"><table class="rouge-table"><tbody><tr>
<td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td> <td class="code"><pre><span class="kt">void</span> <span class="n">UAsyncReadRTAction</span><span class="o">::</span><span class="n">Tick</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadRTData</span><span class="o">-&gt;</span><span class="n">FinishedRead</span><span class="p">)</span>
	<span class="p">{</span>
        <span class="n">ENQUEUE_RENDER_COMMAND</span><span class="p">(</span><span class="n">FReadRTAsync</span><span class="p">)([</span><span class="n">WeakThis</span> <span class="o">=</span> <span class="n">TWeakObjectPtr</span><span class="o">&lt;</span><span class="n">UAsyncReadRTAction</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="n">ReadData</span> <span class="o">=</span> <span class="n">ReadRTData</span><span class="p">](</span><span class="n">FRHICommandListImmediate</span><span class="o">&amp;</span> <span class="n">RHICmdList</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">// Return if we haven't finished the texture create and copy commands</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ReadData</span><span class="o">-&gt;</span><span class="n">TextureFence</span><span class="p">.</span><span class="n">IsValid</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">ReadData</span><span class="o">-&gt;</span><span class="n">TextureFence</span><span class="o">-&gt;</span><span class="n">Poll</span><span class="p">())</span>
			<span class="p">{</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="kt">void</span><span class="o">*</span> <span class="n">OutputBuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">int32</span> <span class="n">Width</span><span class="p">;</span> <span class="n">int32</span> <span class="n">Height</span><span class="p">;</span>
			<span class="n">GDynamicRHI</span><span class="o">-&gt;</span><span class="n">RHIMapStagingSurface</span><span class="p">(</span><span class="n">ReadData</span><span class="o">-&gt;</span><span class="n">Texture</span><span class="p">,</span> <span class="n">ReadData</span><span class="o">-&gt;</span><span class="n">TextureFence</span><span class="p">,</span> <span class="n">OutputBuffer</span><span class="p">,</span> <span class="n">Width</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">RHICmdList</span><span class="p">.</span><span class="n">GetGPUMask</span><span class="p">().</span><span class="n">ToIndex</span><span class="p">());</span>
			<span class="p">{</span>
				<span class="n">ReadPixel</span><span class="p">(</span><span class="n">Width</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="n">OutputBuffer</span><span class="p">,</span> <span class="n">ReadData</span><span class="o">-&gt;</span><span class="n">Texture</span><span class="o">-&gt;</span><span class="n">GetFormat</span><span class="p">(),</span> <span class="n">ReadData</span><span class="o">-&gt;</span><span class="n">PixelColor</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">RHICmdList</span><span class="p">.</span><span class="n">UnmapStagingSurface</span><span class="p">(</span><span class="n">ReadData</span><span class="o">-&gt;</span><span class="n">Texture</span><span class="p">);</span>
			<span class="n">ReadData</span><span class="o">-&gt;</span><span class="n">FinishedRead</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">});</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">OnReadRenderTarget</span><span class="p">.</span><span class="n">Broadcast</span><span class="p">(</span><span class="n">ReadRTData</span><span class="o">-&gt;</span><span class="n">PixelColor</span><span class="p">);</span>
		<span class="n">SetReadyToDestroy</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></td> </tr></tbody></table></code></pre></figure> <p>Bringing all this together, you can take RT pixel reading from a few milliseconds down to about 40 microseconds of total CPU time. If you cache the temporary texture instead of creating it every read you can probably shave off another 20 microseconds, but this is good enough for me. The big tradeoff to using this asynchronous method is that the read now takes 3 frames to complete instead of being done in the same frame, so write your code with that in mind.</p> <div class="row justify-content-sm-center"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/read-pixels-asycnhronous-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/read-pixels-asycnhronous-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/read-pixels-asycnhronous-1400.webp"></source> <img src="/assets/img/read-pixels-asycnhronous.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Asynchronous Pixel Reading" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <div class="caption"> The first highlighted bar is the texture creation/copying kicking off, and the rest of the bars are checking if the aforementioned commands are done. Since this method polls the render fence on tick, the CPU isn't stalled waiting for the GPU to catch up. </div> <p>The code for this asynchronous method is linked below. The plugin is basically just a <a href="https://github.com/nicholas477/AsyncReadRT/blob/main/Source/AsyncReadRT/Private/AsyncReadRTAction.cpp" rel="external nofollow noopener" target="_blank">single blueprint node</a> that kicks off the texture creation/copy command, checks on tick if they’re done, then maps the texture and copies it. The node is called <code class="language-plaintext highlighter-rouge">Async Read Render Target</code>.</p> <h1 id="download-links">Download Links</h1> <ul> <li><a href="https://github.com/nicholas477/AsyncReadRT/" rel="external nofollow noopener" target="_blank">Plugin Link</a></li> </ul> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Nicholas Chalkley. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: June 30, 2024. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script type="text/javascript">$(function(){$('[data-toggle="tooltip"]').tooltip()});</script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js"></script> <script defer src="/assets/js/common.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-8SQ3HQJMBJ"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-8SQ3HQJMBJ");</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>